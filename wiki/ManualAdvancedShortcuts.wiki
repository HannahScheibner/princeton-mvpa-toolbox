= Advanced Manual =

== Handy shortcuts ==

We've tried to add some minor labour-saving devices to make using the toolbox easier.


=== Getting the latest object names ===

Much of the time, you'll want to look at or use the most recently-created pattern, or run or regressors or mask. Sometimes, it can be a pain to remember or type long object names, and sometimes when writing functions, you may not know in advance what the latest names will be.

To make this easier, the toolbox keeps track of the latest object of each type that was initialized as subj.p, .r, .s and .m. This way, you could type:

{{{
>> get_object(subj,'pattern',subj.p) 

as a bit of a shorthand. 
}}}

Note: this is one of those handy labour-saving devices that might prove a terrible idea if used carelessly. For instance, be careful after creating a group, since it's unlikely that you'll want to specifically access the last item in that group.

Note: We deliberately decided not to have the remove functions alter the subj.x shortcuts when removing the highest-numbered mat or object of its type. This way, if you forget to update them yourself, you'll get an error. If we were to automatically set them to the next highest-numbered item, you might not notice and end up with a subtil and devilish bug.

If you have ideas for other ways to speed up frequently-performed tasks or minimise how much typing users have to do, we'd be happy to [#_Contact_details hear from you].


=== Getting the mat immediately from a duplicated object ===

Often, you'll find yourself doing the following:

1. duplicating an object

2. getting the _mat_ from the new object

3. modifying it

4. setting it back into the object.

To reduce this down by one step, it's worth noting that the [http://www.csbmb.princeton.edu/mvpa/docs/m2html/duplicate_object.html _duplicate_object.m_] function will return the duplicated object's _mat_ as its second argument, allowing you to combine the first two steps in one line:

{{{ 
>> [subj duplicated_mat] = duplicate_obj(subj,objtype,old_objname,new_objname);
 }}}


== Creating custom functions ==

It is very easy to override the toolbox's default functions with your own custom-created function that the main toolbox control functions can call when appropriate. For instance, if you don't want to use the default backpropagation classifier, or the default ANOVA statmap generator, you can drop your own functions in instead, and the toolbox's no-peeking cross-validation control functions will use your custom functions instead at the appropriate times.

At the moment, there are various places where you can substitute your own functions ' click on the links in the [#_Places_that_can list] below to skip to the section where the specific details for each are described.

If you do create a custom function and you think others might benefit from it, we'd really like to [#_Contact_details hear from you] so that we can incorporate it into future releases of the toolbox.


=== Places that can call custom function ===

 * [#_statmap statmap generation] ' _feature_selection.m_ and _peek_feature_selection.m_ can take optional _statmap_funct_ and _statmap_arg_ arguments
 * [#_Creating_your_own classifier training] ' _cross_validation.m_ can take an optional _train_funct_ function name string
 * [#_Creating_your_own classifier test] ' _cross_validation.m_ can take an optional _test_funct_ function name string
 * [#_Creating_your_own classifier performance metrics] ' _cross_validation.m_ can take an optional _perfmet_functs_ cell array of performance metric function name strings


=== Requirements for custom functions that modify the _subj_ structure ===

Any custom functions that modify the _subj_ structure (usually by creating a new object) should fulfil the following requirements, if they're going to be well-behaved toolbox citizens:

路 take in a _subj_ structure as their first argument

路 return the modified _subj_ structure as their first output argument

路 if the custom function creates a new _subj_ structure object, you should add a line to the help comments that says 'Adds the following objects:' and a list of the objects/groups that get created

路 if the custom function creates a new _subj_ structure object, you should display something like:

sprintf('Created %s called %s',objtype,objname)

 * should call the [http://www.csbmb.princeton.edu/mvpa/docs/m2html/add_created.html _add_created.m_] with fields for the name of the function and any arguments it takes
 * should call [http://www.csbmb.princeton.edu/mvpa/docs/m2html/add_history.html _add_history.m_] to add a line describing themselves to their own freetext history narrative
 * try and do some error-checking on the inputs, if there are any assumptions that the function makes, to help future users avoid making hard-to-debug booboos


== Optional arguments ==

All of the functions in the toolbox use the same conventions for optional arguments, since they all rely on _[http://www.csbmb.princeton.edu/mvpa/docs/m2html/propval.html propval.m]_. This is a standalone function that makes it very easy to specify what optional arguments a function should accept, in any order, what default arguments it should use if they're not supplied, and with lots of error-checking and warning.

Optional arguments must be supplied in property/value pairs, e.g.

{{{
>> summarize(subj,'display_groups',false) 

Here, the property being specified is 'display_groups' and the value being specified is _false_. Multiple optional arguments can be specified at once, and in any order, e.g.

>> summarize(subj,'display_groups',false,'objtype','selector')

or:

>> summarize(subj,'objtype','selector','display_groups',false)
 }}}

In this case, the property/value pairings are as follows:

||  _Property_ ||  _Value_ ||
||  display_groups ||  false ||
||  objtype ||  'selector' ||


Properties are always strings, and always come first in the pair. Values can be strings, or any other type, and always come second.

By the way, for more information on the [http://www.csbmb.princeton.edu/mvpa/docs/m2html/summarize.html summarize.m] function, see also: [#_Viewing_the_subj Viewing the subj structure] and [:MVPA manual:How can I slim down the output from summarize.m].

In the help for a function, the triple-dot at the end of the function declaration denotes that it takes optional arguments, e.g.

{{{
>> help summarize 

[] = summarize(subj,...)

Below, the help says:

DISPLAY_GROUPS (optional, default = blah) ' blah blah

OBJTYPE (optional, default = blah) ' blah blah
 }}}

In this way, all the allowed optional argument properties will be listed, along with their default values (if they are left unspecified), and what terrible things will be wrought by each.

This is a powerful and flexible mechanism, since it allows us to keep basic function declarations simple if you want to use the defaults, but doesn't restrict the user if they do want to specify niceties.

There is one further way in which optional arguments can be supplied. If calling a function with lots of optional arguments, it can be a pain to specify them all each time. In this case, you can bundle them all together in a structure, and just feed that in. Propval.m will understand and deconstruct the structure in exactly the same way as before, e.g.

{{{
>> summ_args.display_groups = false; 

>> summ_args.objtype = 'selector';

>> summarize(subj,summ_args)
 }}}

See the help for [http://www.csbmb.princeton.edu/mvpa/docs/m2html/propval.html propval.m] for more information.

Note: there is one exception - [http://www.csbmb.princeton.edu/mvpa/docs/m2html/summarize.html summarize.m] has a special single optional boolean argument that determines whether or not to display all the members of a group. This is for the user's convenience, since _summarize.m_ gets called so much, but may be deprecated in future versions.