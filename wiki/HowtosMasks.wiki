= Howtos =



=== How do I figure out which voxels are common to two masks' ===

This is very easy. Since masks are boolean 3D matrices, you could just try:

{{{
>> mask1 = get_mat(subj,'mask','mask1'); 

>> mask2 = get_mat(subj,'mask','mask2');

>> common_voxels = mask1 & mask2; 
}}}

That will produce a third boolean 3D matrix, with 1s where both mask1'' and ''mask2'' had 1s. You could then create a new ''common_voxels'' mask object, and use this to mask a pattern using [m2html/create_pattern_from_mask.html ''create_pattern_from_mask.m'']. ''


=== How do I find the coordinates of active voxels in a mask' ===

The mat'' of a mask object is a 3D boolean object. If you would like an (''nVox'' x ''3'') matrix of ''x''/''y''/''z'' Cartesian coordinates listing those voxels that are active in the volume: ''

{{{
>> mymask = get_mat(subj,'mask','mymaskname'); 

>> [x y z] = ind2sub(size(mymask),find(mymask)); % untested xxx 
}}}


=== How do I create a mask that allows all the features through' (Creating a wholevol mask) ===

The volume collected by the fMRI scanner is a cuboid. Normally, you'll probably only want to include the voxels inside the cranium but you may want a mask that includes absolutely every single one of those voxels, which we will term a 'wholevol' mask. It's often useful to try your voxel selection methods on wholevol masks as a sanity-check. If many of the voxels getting selected are outside the brain, that's a bad sign.

All you need to do is create an all-ones 3D matrix. If your volume is 64x64x40:

{{{
>> wholevol = ones(64,64,40); 

>> subj = init_object(subj,'mask','wholevol');

>> subj = set_mat(subj,'mask','wholevol',wholevol); 
}}}

Then, if you want to load in the data for every single voxel from some BRIK file, then you would call [m2html/load_afni_pattern.html load_afni_pattern.m]'' as before, using 'wholevol' as the mask argument, e.g. ''

{{{
>> for i=1:10 

raw_filenames{i} = sprintf('haxby8_r%i+orig',i);

end

>> subj = load_afni_pattern(subj,'epi','wholevol',raw_filenames); 
}}}

Note: this could involve loading in hundreds of thousands of voxels' worth of data, which will probably be too RAM-intensive to be manageable. There's not a lot you can do about this. Storing the data as singles, rather than doubles is probably a good start ' see [:MVPA manual:How do I store an object as singles rather than double].


=== Creating a wholebrain (intra-cranial) mask, or other anatomical mask ===

Currently, there are no facilities in the toolbox for automatically defining the cranial boundaries to create intra-cranial masks, or for drawing anatomical ROIs. We recommend that you use a function like AFNI's 3dAutomask'' for defining intra-cranial boundaries, or draw the ROIs yourself, save to a BRIK file, and then use ''[m2html/load_afni_mask.html load_afni_mask.m]'' to read that mask in to Matlab. ''

For information about other neuroimaging packages, see [#_Importing Importing]''. ''


== Pre-classification ==


=== How can I handpick timepoints to exclude from my analysis' ===

Don't delete any timepoints from your patterns or regressors. Instead, just tell [m2html/create_xvalid_indices.html create_xvalid_indices.m]'' to use a selector as a kind of temporal mask to censor out the timepoints you don't want. Imagine you have 1000 TRs, and you want to exclude the 111th (because that's the point in your experiment where Bilbo disappears): ''

{{{
>> nTRs = 1000; 

>> temp_sel= ones(1,nTRs);

>> temp_sel(111) = 0;

>> subj = init_object(subj,'selector','no_bilbo');

>> subj = set_mat(subj,'selector',no_bilbo',temp_sel);

Now, when you call ''create_xvalid_indices.m'', feed in the ''no_bilbo'' selectors object as the ''actives_selname'':

>> subj = create_xvalid_indices(subj,'runs', ...

'actives_selname','no_bilbo'); 
}}}

Note: this method will only exclude these timepoints from functions that use the create_xvalid_indices.m''. They still exist in regressors or patterns or other objects. It's just that they will be ignored when creating the cross-validation selector group that gets used for feature selection and classification later on. Early functions like ''zscore_runs.m'' that don't use the cross-validation selector group will still include these timepoints. This is deliberate, since we recommend that you include all your TRs when zscoring. ''

The main advantage of this method is that it doesn't require you to actually delete the TRs that you don't want from your patterns, so that if you change your mind, you can easily rerun your analysis by feeding in a different actives_selname'' selector to ''create_xvalid_indices.m''. ''


=== How can I exclude rest timepoints from my analysis' ===

First, read '[:MVPA manual:How can I handpick timepoints to exclude from my analysis']'.

This time, instead of hand-picking the timepoints to exclude individually, you want to exclude all the timepoints in your regressors matrix that don't have an active condition. As above, this simply involves setting those timepoints in your actives_selname'' selector to 0. For instance: ''

{{{
>> regs = get_mat(subj,'regressors','my_conds'); 

>> temp_sel = ones(1,size(regs,2));

>> temp_sel(find(sum(regs)==0)) = 0;

>> subj = init_object(subj,'selector','no_rest');

>> subj = set_mat(subj,'selector',no_rest',temp_sel);

>> subj = create_xvalid_indices(subj,'runs','actives_selname','no_rest');
 }}}


=== How can I exclude conditions from my analysis' ===

We recommend using the same method as described first in '[#_How_do_I How can I handpick timepoints to exclude from my analysis']' and elaborated in '[#_How_can_I_1 How can I exclude rest timepoints from my analysis']'.

The only difference here is that we are going to create a new regressors matrix with a reduced number of condition-rows beforehand. First, create a new regressors object by duplicating the current set of regressors. Then remove the appropriate condition-rows from the new regressors, and the appropriate condition-name string from the condnames'' field. For example, to create a new regressors object called ''regs_no_3 ''that lacks the third condition from ''regs_original''. ''

{{{
>> subj = duplicate_object(subj,'regressors','regs_original','regs_no_3'); 

>> regs_no_3_mat = get_mat(subj,'regressors','regs_no_3');

>> regs_no_3_mat(3,:) = [];

>> subj = set_mat(subj,'regressors','regs_no_3',regs_no_3_mat);

>> condnames_no_3 = get_objfield(subj,'regressors','regs_no_3','condnames');

>> condnames_no_3(3) = [];

>> subj = set_objfield(subj,'regressors','regs_no_3','condnames',condnames_no_3); 
}}}

Now, regs_no_3'' will contain as many timepoints as ''regs_original'', but fewer condition-rows, and more 'rest timepoints', i.e. timepoints with no active conditions. Now, we can just proceed as described above for [#_How_can_I_1 excluding rest] from your analysis to ensure that those 'rest' timepoints are ignored when generating the statmap and doing classification. In other words, the third condition won't feature at all in any steps of the analysis that use selectors in the group created by ''create_xvalid_indices.m''. ''

Proceeding from now on exactly as described in '[#_How_can_I_1 How can I exclude rest timepoints from my analysis']':

{{{
>> regs = get_mat(subj,'regressors','my_conds'); 

>> temp_sel = ones(1,size(regs_no_3,2));

>> temp_sel(find(sum(regs_no_3)==0)) = 0;

>> subj = init_object(subj,'selector','sel_no_3');

>> subj = set_mat(subj,'selector',sel_no_3',temp_sel);

>> subj = create_xvalid_indices(subj,'runs','actives_selname','sel_no_3'); 
}}}


=== How can I exclude rest and hand-picked timepoints and some conditions' ===

Create a separate boolean temporal mask selector for each, as above. Then create a new selector that is the 'AND' of all of those selectors, and feed that in.